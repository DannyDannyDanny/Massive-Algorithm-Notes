* [Home](README.md)
### Question 2 - The Highest α-Free Ancestor Problem

Let $T$ be a rooted tree with $n$ nodes. Each leaf in $T$ is assigned a label from a set of colors $C$. Given a node $v ∈ T$, the subtree rooted at $v$, denoted $T(v)$, is the tree consisting of $v$ and all descendants of $v$. A subtree $T(v)$ is $α$-free if it does not contain a leaf with label $α$. We are interested in efficient data structures for $T$ that support the following query. Let $l$ be a leaf in $T$ and $α$ a color in $C$.

$HFA(l, α)$: return the highest ancestor $a$ of $l$ such that $T(a)$ is $α$-free.

Give a linear-space data structure for $T$ that supports fast $HFA$ queries. Ignore the preprocessing time.

#### Solution v.2 in $O(\log \log n)$ time

> Is it a good idea to split it up like this? i.e Preprocessing, Running, Time complexity, Space complexity.

###### Preprocessing
* Perform Euler Tour of **T**, storing the resulting array, **E** as well as the depth at each node.
* Construct hash-table, **H**, where key-value pairs have some label, **{c | ∈ C}**, as key and the indices at which **c** occurs.
* The indices in **H** are stored as y-fast-tries for fast successor and predecessor queries.

###### Running **HFA(l,ɑ)**
* To perform **HFA(l,ɑ)**, query indices of **l** in **H** and find the successor node **s** and predecessor node **p** to **ɑ**.
* Either the **p** or **s** in **H[l]** will be the most closely related node with label **l**.
* Find the depth of the lowest common ancestor of **s**-**ɑ** and **p**-**ɑ** using plus-minus-RMQ on **E**.
* Of the resulting nodes, **LCA(ɑ,p)** and **LCA(ɑ,s)**, choose node deepest in the tree using the stored depths.
* Return the child which is an ancestor to **ɑ**.

###### Time complexity
Performing **HFA(l,ɑ)** requires:
* look-up in **H** - constant time
* successor and predecessor queries - **O(log log n)** time
* LCA on both successor and predecessor - constant time.
* Finding the deepest LCA and returning its child / ancestor to **ɑ** - constant time.
* Combined **O(log log n)** time.

###### Space complexity
Original tree **O(n)**, Array from Euler Tour **O(2·n)** and hash table with y-fast-tries with indices of labelled leaf nodes **O(C+n)**. As **C≤N** the combined space consumption is **O(n)**.

[Stack Overflow brainstorming](https://stackoverflow.com/questions/51537577/given-some-child-node-in-a-rooted-tree-how-can-you-find-its-most-closely-relat)
